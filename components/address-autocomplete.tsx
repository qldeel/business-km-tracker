"use client"

import type React from "react"

import { useEffect, useRef, useState } from "react"
import { loadGoogleMapsAPI } from "@/lib/google-maps"

interface AddressAutocompleteProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
  id?: string
  onError?: (error: string) => void
  onPlaceSelect?: (place: any) => void
}

export function AddressAutocomplete({
  value,
  onChange,
  placeholder,
  id,
  onError,
  onPlaceSelect,
}: AddressAutocompleteProps) {
  const inputRef = useRef<HTMLInputElement>(null)
  const autocompleteRef = useRef<any>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [inputValue, setInputValue] = useState(value)
  const [lastProcessedPlaceId, setLastProcessedPlaceId] = useState<string | null>(null)
  const checkIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const onChangeRef = useRef(onChange)
  const onErrorRef = useRef(onError)
  const onPlaceSelectRef = useRef(onPlaceSelect)

  // Sync input value with external value
  useEffect(() => {
    setInputValue(value)
  }, [value])

  // Update refs when props change
  useEffect(() => {
    onChangeRef.current = onChange
    onErrorRef.current = onError
    onPlaceSelectRef.current = onPlaceSelect
  }, [onChange, onError, onPlaceSelect])

  // Shared function to process place selection
  const processPlaceSelection = (place: any, source: string) => {
    console.log(`üîÑ [AddressAutocomplete] Processing place selection from ${source}`)
    
    if (!place || !place.place_id) {
      console.log(`‚ùå [AddressAutocomplete] No valid place data from ${source}`)
      return false
    }

    // Prevent duplicate processing of the same place
    if (lastProcessedPlaceId === place.place_id) {
      console.log(`üîÑ [AddressAutocomplete] Place ${place.place_id} already processed, skipping`)
      return false
    }

    console.log(`‚úÖ [AddressAutocomplete] Processing new place from ${source}:`, place.place_id)
    console.log(`üè¢ [AddressAutocomplete] Place name:`, place.name)
    console.log(`üìç [AddressAutocomplete] Place formatted_address:`, place.formatted_address)
    console.log(`üè∑Ô∏è [AddressAutocomplete] Place types:`, place.types)
    
    let selectedAddress = ""

    // If it's a business/establishment, use the name + address
    if (
      place.name &&
      place.types &&
      (place.types.includes("establishment") ||
        place.types.includes("point_of_interest") ||
        place.types.includes("store") ||
        place.types.includes("restaurant") ||
        place.types.includes("lodging") ||
        place.types.includes("hospital") ||
        place.types.includes("school") ||
        place.types.includes("university"))
    ) {
      selectedAddress = `${place.name}, ${place.formatted_address}`
      console.log(`üè¢ [AddressAutocomplete] Business detected - using name + address format`)
    } else {
      // For regular addresses, just use the formatted address
      selectedAddress = place.formatted_address || ""
      console.log(`üè† [AddressAutocomplete] Regular address - using formatted_address only`)
    }

    console.log(`üéØ [AddressAutocomplete] Final selectedAddress:`, selectedAddress)

    if (selectedAddress) {
      setLastProcessedPlaceId(place.place_id)
      console.log(`üì§ [AddressAutocomplete] Calling onChange with selectedAddress:`, selectedAddress)
      onChangeRef.current(selectedAddress)
      console.log(`üîÑ [AddressAutocomplete] Setting inputValue to:`, selectedAddress)
      setInputValue(selectedAddress)

      // Notify parent component about the selected place
      if (onPlaceSelectRef.current) {
        console.log(`üîî [AddressAutocomplete] Calling onPlaceSelect with place data`)
        onPlaceSelectRef.current(place)
      }
      return true
    } else {
      console.log(`‚ùå [AddressAutocomplete] selectedAddress is empty, not updating`)
      return false
    }
  }


  useEffect(() => {
    const initializeAutocomplete = async () => {
      try {
        console.log("üöÄ [AddressAutocomplete] Starting Google Maps API initialization")
        await loadGoogleMapsAPI()
        console.log("‚úÖ [AddressAutocomplete] Google Maps API loaded successfully")

        if (inputRef.current && window.google) {
          console.log("‚úÖ [AddressAutocomplete] Input ref and window.google available")
          console.log("üîß [AddressAutocomplete] Creating autocomplete instance...")
          
          // Create autocomplete instance with business-focused configuration
          autocompleteRef.current = new window.google.maps.places.Autocomplete(inputRef.current, {
            types: ["establishment", "geocode"], // Include businesses and addresses
            componentRestrictions: { country: ["au"] }, // Restrict to Australia only
            fields: ["formatted_address", "geometry", "name", "place_id", "types", "business_status"],
          })
          
          console.log("‚úÖ [AddressAutocomplete] Autocomplete instance created:", autocompleteRef.current)
          console.log("üîó [AddressAutocomplete] Adding place_changed listener...")

          // Listen for place selection
          autocompleteRef.current.addListener("place_changed", () => {
            console.log("üî• [AddressAutocomplete] place_changed listener triggered!")
            const place = autocompleteRef.current.getPlace()
            console.log("üó∫Ô∏è [AddressAutocomplete] Raw place data:", JSON.stringify(place, null, 2))
            processPlaceSelection(place, "place_changed event")
          })

          console.log("‚úÖ [AddressAutocomplete] place_changed listener added successfully")
          
          setIsLoading(false)
          setError(null)
        } else {
          console.log("‚ùå [AddressAutocomplete] Missing inputRef.current or window.google")
          console.log("‚ùå [AddressAutocomplete] inputRef.current:", inputRef.current)
          console.log("‚ùå [AddressAutocomplete] window.google:", window.google)
        }
      } catch (err) {
        console.error("‚ùå [AddressAutocomplete] Failed to load Google Maps API:", err)
        const errorMessage = typeof err === "string" ? err : "Failed to load address suggestions"
        setError(errorMessage)
        setIsLoading(false)
        onErrorRef.current?.(errorMessage)
      }
    }

    initializeAutocomplete()

    return () => {
      if (autocompleteRef.current && window.google) {
        window.google.maps.event.clearInstanceListeners(autocompleteRef.current)
      }
      if (checkIntervalRef.current) {
        clearInterval(checkIntervalRef.current)
      }
    }
  }, [])

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value
    console.log("üî§ [AddressAutocomplete] Input change - typed value:", newValue)
    setInputValue(newValue)
    console.log("üì§ [AddressAutocomplete] Calling onChange with typed value:", newValue)
    onChange(newValue)
  }

  return (
    <div className="relative">
      <input
        ref={inputRef}
        id={id}
        type="text"
        value={inputValue}
        onChange={handleInputChange}
        onClick={() => console.log("üñ±Ô∏è [AddressAutocomplete] Input field clicked")}
        onFocus={() => {
          console.log("üéØ [AddressAutocomplete] Input field focused - starting place checking")
          // Start checking for place changes every 300ms when focused
          if (checkIntervalRef.current) {
            clearInterval(checkIntervalRef.current)
          }
          checkIntervalRef.current = setInterval(() => {
            if (autocompleteRef.current) {
              const place = autocompleteRef.current.getPlace()
              if (place && place.place_id && place.place_id !== lastProcessedPlaceId) {
                console.log("‚è∞ [AddressAutocomplete] Interval check found place selection!")
                console.log("‚è∞ [AddressAutocomplete] Place:", place)
                processPlaceSelection(place, "interval check")
              }
            }
          }, 300)
        }}
        onBlur={(e) => {
          console.log("üòµ‚Äçüí´ [AddressAutocomplete] Input field blurred - stopping place checking")
          // Stop the interval checking
          if (checkIntervalRef.current) {
            clearInterval(checkIntervalRef.current)
            checkIntervalRef.current = null
          }
          
          // Do one final check after blur
          setTimeout(() => {
            if (autocompleteRef.current) {
              const place = autocompleteRef.current.getPlace()
              console.log("üòµ‚Äçüí´ [AddressAutocomplete] Final place check on blur:", place)
              if (place && place.place_id && place.place_id !== lastProcessedPlaceId) {
                console.log("üö® [AddressAutocomplete] Processing place selection from final blur check")
                processPlaceSelection(place, "blur check")
              }
            }
          }, 100)
        }}
        onKeyDown={(e) => {
          console.log("‚å®Ô∏è [AddressAutocomplete] Key pressed:", e.key)
          if (e.key === 'Enter' || e.key === 'Tab') {
            console.log("‚å®Ô∏è [AddressAutocomplete] Enter/Tab pressed - checking for place...")
            setTimeout(() => {
              if (autocompleteRef.current) {
                const place = autocompleteRef.current.getPlace()
                console.log("‚å®Ô∏è [AddressAutocomplete] Place after Enter/Tab:", place)
              }
            }, 100)
          }
        }}
        onMouseDown={() => console.log("üñ±Ô∏è [AddressAutocomplete] Mouse down on input")}
        onMouseUp={() => console.log("üñ±Ô∏è [AddressAutocomplete] Mouse up on input")}
        placeholder={error ? "Enter address manually" : isLoading ? "Loading suggestions..." : placeholder}
        disabled={isLoading}
        className={`flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 ${error ? "border-red-300" : ""}`}
      />
      {isLoading && (
        <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900"></div>
        </div>
      )}
    </div>
  )
}
